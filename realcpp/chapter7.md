# chapter 7

## 7.3
提供构造函数后不会有默认生成的构造函数,如果要需要显示构造出来
如:
> Screen()=default;
> > 此句为内联

>Screen(a a,b,b,c,c):...
>>隐式构造

构造函数与get,set应该为默认inline

最好在类外部定义的地方声明inline

### 重载成员函数
同非成员函数
>类里面的函数为成员函数,同样的还有成员变量
普通定义的函数是非成员函数,别弄混了

### 可变数据类型
## mutable data member_
修改数据成员
即使在const成员函数中也能修改数据
>一般不能?忘记了..

### __待查证__


### 7.3.1作业
>7章看完回来做
习7.23：编写你自一个Scren类
24.三个构造函数 1默认2构造函数接受宽和高的值，然后将contents初始化成给定数量的空白；第三个构造函数接受宽和高的值以及一个字符，该字符作为初始化之后屏幕的内容。
练习7.25：Screen能安全地依赖于拷贝和赋值操作的默认版本吗？如果能，为什么？如果不能，为什么？
练习7.26：将Sales_data：：avg己的Screen类。练习7.24：给你的Screen类添加三个构造函数：一个默认构造函数；另_price定义成内联函数。

### 7.3.2
如果set返回左值(函数返回类型有引用),则可以作为对象继续使用对应函数
如
screen.move().set()
则为同个对象
如非左值,则相当于
>temp=screen.move
temp.set()

## 以上函数均为返回*this对象

---

### 从const成员函数返回*this

定义一个display函数,此函数不需要改变内容,故使用const
如果此时将__返回左值__的display函数后面接set,会报错,因为display会返回常量引用,set无法改变

### 基于const重载

通过区分是否const对齐重载

如Screen &display(){
    do_display();
    }
const Screen &display()...

之后会根据其对象决定调用版本...


>> do_display单独放出来是为了美观,在类中声明使其隐式内联,消耗性能极小


### 7.3.2作业
练习7.27：给你自己的Screen类添加move、set和display函数，通过执行下面的代码检验你的类是否正确。
练习7.28：如果move、set和display函数的返回类型不是Screen&而是Screen，则在上一个练习中将会发生什么情况？
练习7.29：修改你的Screen类，令move、set和display函数返回Screen并检查程序的运行结果，在上一个练习中你的推测正确吗？
练习7.30：通过this指针使用成员的做法虽然合法，但是有点多余。讨论显式地使用指针访问成员的优缺点。


### 类类型
唯一,即使成员完全一样,也是不同类型
类名就是类类型
aa a;
== class aa avg(来自c语言,别用)

#### 前向声明: 
把声明和定义分开
class Screen;
此时他是 __不完全类型__

此时仅能用于返回指针or引用.也能声明以不完全之身作为参数或返回类型
但不能创建对象

后续7.6中将描述另一种情况,翘首以待

### 7.3.3节练习
习7.31：定义一对类X和Y，其中X包含一个指向Y的指针，而Y包含一个类型为X的对象。


## 7.3.4友元二周目
可定义对象:非函数;类;其他类成员函数
如class Screen{
    friend class window_mgr;
}
此时window_mgr可调用screen的私有部分
window_mgr{
    Screen screens;
}
__友元不具有传递性__


__如果友元是非成员函数,就算在内部已经定义,也需要在外部重新定义__
友元声明仅影响访问权限,不是真的声明

### 7.3.4练习
习7.32：定义你自己的Screen和Window_mgr，其中clear是Window_mgr的成员，是Screen的友元。


## 7.4类的作用域

作用域外只能用成员访问运算符来访问
>Screen scr();
Screen *p=&src;
src.get()
p->get();//指针才用->

作用域就算类内

遇到类名后就能使用作用域里的了..

练习7.33：如果我们给Screen添加一个如下所示的size成员将发生什么情况？如果出现了问题，请尝试修改它。
pos Screen::size() const{
    return height*width;
}

### 名字查找
先找名字所在块,在找外层
没找到则报错

对于定义在类中的成员函数来说:

1.编译成员的声明
2.类全部可见后才编译函数体

查找顺序:
1.在函数内部查找
2.在类的作用域中查找,即使定义在函数之后也能用上
3.在外围作用域查找,需要在类之前定义的.有可能被类中的同名隐藏,可以用::height找到全局的那个

### 类中类型名要特殊处理

内层作用域可以重新定义外层作用域中的名字,即使已经使用过,
__但在类中,这不成立,如果成员有种使用了外层的某个名字,该名字代表一种类型,那类不能在之后重新定义该名字了..__
即使定义一样也是如此


7.4.1节练习
练习8.34：如果我们把第256页Screen类的pos的typedef放在类的最后一行会发生什么情况？
练习7.35：解释下面代码的含义，说明其中的Type和initVal分别使用了哪个定义。如果代码存在错误，尝试修改它。


### 7.5
const&引用必须初始化,如果没有默认构造函数也必须初始化
如果是const,引用或者某种未提供构造函数的类型,可以通过构造函数初始值列表为成员提供初值
>xxx::xxx(int ii):i(ii),j(ii),ri(ii){}

区别:底层效率
初始化直接初始化
后者初始化再赋值

默认实参和构造函数?
前者类似只接受1个string'的构造实参区别是构造函数用这个初始化bookNo,默认则隐式使用string初始化bookNo
如果构造函数提供所有实参,则他定义了默认构造函数

### 7.5.1练习

## 7.5.2委托构造函数 C++11
将构造函数委托给其他构造函数

该函数只有一个唯一入口:类名本身
将构造函数
Sales_data(std::istream &is):Sales_data(){
    read(is,*this);
}
string构造也是一样的?
>好处:可以直接修改默认构造函数?然后快速修改全部?
对于运行速度的影响不清楚
使用委托构造函数重新编写你的Sales_data类，给每个构造函数体添加一条语句，
令其一旦执行就打印一条信息。用各种可能的方式分别创建Sales_data对象，认真研
究每次输出的信息直到你确实理解了委托构造函数的执行顺序。
练习7.42：对于你在练习7.40（参见7.5.1节，第261页）中编写的类，确定哪些构造函数可以使用委托。如果可以
的话，编写委托构造函数。如果不可以，从抽象概念列表中重新选择一个你认为可以使用委托构造函数的，为挑选
出的这个概念编写类定义


Sales_data obj()是一个函数,而非对象,
Sales_data obj才对

7.43：假定有一个名为NoDefault的类，它有一个接受int的构造函数，但是没有默认构造函数。定义类C，C有一个NoDefault类型的成员，定义C的默认构造函数。
练习7.44：下面这条声明合法吗？如果不，为什么？
练习7.45：如果在上一个练习中定义的vector的元素类型是C，则声明合法吗？为什么？
练习7.46：下面哪些论断是不正确的？为什么？
（a）一个类必须至少提供一个构造函数。
（b）默认构造函数是参数列表为空的构造函数。
（c）如果对于类来说不存在有意义的默认值，则类不应该提供默认构造函数。
（d）如果类没有定义默认构造函数，则编译器将为其生成一个并把每个数据成员初始化成相应类型的默认值。
>>未完成

构造函数的隐式类型转换->